/*
 *          registerInput(KEYSYM, "key.keyboard.unknown", -1);
         registerInput(MOUSE, "key.mouse.left", 0);
         registerInput(MOUSE, "key.mouse.right", 1);
         registerInput(MOUSE, "key.mouse.middle", 2);
         registerInput(MOUSE, "key.mouse.4", 3);
         registerInput(MOUSE, "key.mouse.5", 4);
         registerInput(MOUSE, "key.mouse.6", 5);
         registerInput(MOUSE, "key.mouse.7", 6);
         registerInput(MOUSE, "key.mouse.8", 7);
         registerInput(KEYSYM, "key.keyboard.0", 48);
         registerInput(KEYSYM, "key.keyboard.1", 49);
         registerInput(KEYSYM, "key.keyboard.2", 50);
         registerInput(KEYSYM, "key.keyboard.3", 51);
         registerInput(KEYSYM, "key.keyboard.4", 52);
         registerInput(KEYSYM, "key.keyboard.5", 53);
         registerInput(KEYSYM, "key.keyboard.6", 54);
         registerInput(KEYSYM, "key.keyboard.7", 55);
         registerInput(KEYSYM, "key.keyboard.8", 56);
         registerInput(KEYSYM, "key.keyboard.9", 57);
         registerInput(KEYSYM, "key.keyboard.a", 65);
         registerInput(KEYSYM, "key.keyboard.b", 66);
         registerInput(KEYSYM, "key.keyboard.c", 67);
         registerInput(KEYSYM, "key.keyboard.d", 68);
         registerInput(KEYSYM, "key.keyboard.e", 69);
         registerInput(KEYSYM, "key.keyboard.f", 70);
         registerInput(KEYSYM, "key.keyboard.g", 71);
         registerInput(KEYSYM, "key.keyboard.h", 72);
         registerInput(KEYSYM, "key.keyboard.i", 73);
         registerInput(KEYSYM, "key.keyboard.j", 74);
         registerInput(KEYSYM, "key.keyboard.k", 75);
         registerInput(KEYSYM, "key.keyboard.l", 76);
         registerInput(KEYSYM, "key.keyboard.m", 77);
         registerInput(KEYSYM, "key.keyboard.n", 78);
         registerInput(KEYSYM, "key.keyboard.o", 79);
         registerInput(KEYSYM, "key.keyboard.p", 80);
         registerInput(KEYSYM, "key.keyboard.q", 81);
         registerInput(KEYSYM, "key.keyboard.r", 82);
         registerInput(KEYSYM, "key.keyboard.s", 83);
         registerInput(KEYSYM, "key.keyboard.t", 84);
         registerInput(KEYSYM, "key.keyboard.u", 85);
         registerInput(KEYSYM, "key.keyboard.v", 86);
         registerInput(KEYSYM, "key.keyboard.w", 87);
         registerInput(KEYSYM, "key.keyboard.x", 88);
         registerInput(KEYSYM, "key.keyboard.y", 89);
         registerInput(KEYSYM, "key.keyboard.z", 90);
         registerInput(KEYSYM, "key.keyboard.f1", 290);
         registerInput(KEYSYM, "key.keyboard.f2", 291);
         registerInput(KEYSYM, "key.keyboard.f3", 292);
         registerInput(KEYSYM, "key.keyboard.f4", 293);
         registerInput(KEYSYM, "key.keyboard.f5", 294);
         registerInput(KEYSYM, "key.keyboard.f6", 295);
         registerInput(KEYSYM, "key.keyboard.f7", 296);
         registerInput(KEYSYM, "key.keyboard.f8", 297);
         registerInput(KEYSYM, "key.keyboard.f9", 298);
         registerInput(KEYSYM, "key.keyboard.f10", 299);
         registerInput(KEYSYM, "key.keyboard.f11", 300);
         registerInput(KEYSYM, "key.keyboard.f12", 301);
         registerInput(KEYSYM, "key.keyboard.f13", 302);
         registerInput(KEYSYM, "key.keyboard.f14", 303);
         registerInput(KEYSYM, "key.keyboard.f15", 304);
         registerInput(KEYSYM, "key.keyboard.f16", 305);
         registerInput(KEYSYM, "key.keyboard.f17", 306);
         registerInput(KEYSYM, "key.keyboard.f18", 307);
         registerInput(KEYSYM, "key.keyboard.f19", 308);
         registerInput(KEYSYM, "key.keyboard.f20", 309);
         registerInput(KEYSYM, "key.keyboard.f21", 310);
         registerInput(KEYSYM, "key.keyboard.f22", 311);
         registerInput(KEYSYM, "key.keyboard.f23", 312);
         registerInput(KEYSYM, "key.keyboard.f24", 313);
         registerInput(KEYSYM, "key.keyboard.f25", 314);
         registerInput(KEYSYM, "key.keyboard.num.lock", 282);
         registerInput(KEYSYM, "key.keyboard.keypad.0", 320);
         registerInput(KEYSYM, "key.keyboard.keypad.1", 321);
         registerInput(KEYSYM, "key.keyboard.keypad.2", 322);
         registerInput(KEYSYM, "key.keyboard.keypad.3", 323);
         registerInput(KEYSYM, "key.keyboard.keypad.4", 324);
         registerInput(KEYSYM, "key.keyboard.keypad.5", 325);
         registerInput(KEYSYM, "key.keyboard.keypad.6", 326);
         registerInput(KEYSYM, "key.keyboard.keypad.7", 327);
         registerInput(KEYSYM, "key.keyboard.keypad.8", 328);
         registerInput(KEYSYM, "key.keyboard.keypad.9", 329);
         registerInput(KEYSYM, "key.keyboard.keypad.add", 334);
         registerInput(KEYSYM, "key.keyboard.keypad.decimal", 330);
         registerInput(KEYSYM, "key.keyboard.keypad.enter", 335);
         registerInput(KEYSYM, "key.keyboard.keypad.equal", 336);
         registerInput(KEYSYM, "key.keyboard.keypad.multiply", 332);
         registerInput(KEYSYM, "key.keyboard.keypad.divide", 331);
         registerInput(KEYSYM, "key.keyboard.keypad.subtract", 333);
         registerInput(KEYSYM, "key.keyboard.down", 264);
         registerInput(KEYSYM, "key.keyboard.left", 263);
         registerInput(KEYSYM, "key.keyboard.right", 262);
         registerInput(KEYSYM, "key.keyboard.up", 265);
         registerInput(KEYSYM, "key.keyboard.apostrophe", 39);
         registerInput(KEYSYM, "key.keyboard.backslash", 92);
         registerInput(KEYSYM, "key.keyboard.comma", 44);
         registerInput(KEYSYM, "key.keyboard.equal", 61);
         registerInput(KEYSYM, "key.keyboard.grave.accent", 96);
         registerInput(KEYSYM, "key.keyboard.left.bracket", 91);
         registerInput(KEYSYM, "key.keyboard.minus", 45);
         registerInput(KEYSYM, "key.keyboard.period", 46);
         registerInput(KEYSYM, "key.keyboard.right.bracket", 93);
         registerInput(KEYSYM, "key.keyboard.semicolon", 59);
         registerInput(KEYSYM, "key.keyboard.slash", 47);
         registerInput(KEYSYM, "key.keyboard.space", 32);
         registerInput(KEYSYM, "key.keyboard.tab", 258);
         registerInput(KEYSYM, "key.keyboard.left.alt", 342);
         registerInput(KEYSYM, "key.keyboard.left.control", 341);
         registerInput(KEYSYM, "key.keyboard.left.shift", 340);
         registerInput(KEYSYM, "key.keyboard.left.win", 343);
         registerInput(KEYSYM, "key.keyboard.right.alt", 346);
         registerInput(KEYSYM, "key.keyboard.right.control", 345);
         registerInput(KEYSYM, "key.keyboard.right.shift", 344);
         registerInput(KEYSYM, "key.keyboard.right.win", 347);
         registerInput(KEYSYM, "key.keyboard.enter", 257);
         registerInput(KEYSYM, "key.keyboard.escape", 256);
         registerInput(KEYSYM, "key.keyboard.backspace", 259);
         registerInput(KEYSYM, "key.keyboard.delete", 261);
         registerInput(KEYSYM, "key.keyboard.end", 269);
         registerInput(KEYSYM, "key.keyboard.home", 268);
         registerInput(KEYSYM, "key.keyboard.insert", 260);
         registerInput(KEYSYM, "key.keyboard.page.down", 267);
         registerInput(KEYSYM, "key.keyboard.page.up", 266);
         registerInput(KEYSYM, "key.keyboard.caps.lock", 280);
         registerInput(KEYSYM, "key.keyboard.pause", 284);
         registerInput(KEYSYM, "key.keyboard.scroll.lock", 281);
         registerInput(KEYSYM, "key.keyboard.menu", 348);
         registerInput(KEYSYM, "key.keyboard.print.screen", 283);
         registerInput(KEYSYM, "key.keyboard.world.1", 161);
         registerInput(KEYSYM, "key.keyboard.world.2", 162);
 */

package wafflestomper.ghostwriter.modified_mc_files;


import java.util.List;
import java.util.ListIterator;

import com.google.common.collect.Lists;
import com.mojang.blaze3d.platform.GlStateManager;

import net.minecraft.client.gui.AbstractGui;
import net.minecraft.client.gui.IGuiEventListener;
import net.minecraft.client.gui.chat.NarratorChatListener;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.client.gui.widget.button.Button;
import net.minecraft.client.gui.widget.button.ChangePageButton;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.client.resources.I18n;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.CompoundNBT;
import net.minecraft.nbt.ListNBT;
import net.minecraft.nbt.StringNBT;
import net.minecraft.network.play.client.CEditBookPacket;
import net.minecraft.util.Hand;
import net.minecraft.util.SharedConstants;
import net.minecraft.util.Util;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.text.TextFormatting;
import net.minecraftforge.api.distmarker.Dist;
import net.minecraftforge.api.distmarker.OnlyIn;

// Note: this *should be* identical to the standard EditBookScreen, just with necessary methods set to protected instead of protected
//       It's either this or reflection
@OnlyIn(Dist.CLIENT)
public class EditBookScreenMod extends Screen {
   protected final PlayerEntity editingPlayer;
   protected final ItemStack book;
   protected boolean bookIsModified; // field_214234_c;
   protected boolean bookGettingSigned; // field_214235_d;
   protected int updateCount; // field_214236_e;
   protected int currPage; //field_214237_f
   protected final List<String> bookPages = Lists.newArrayList(); // field_214238_g
   protected String bookTitle = ""; // field_214239_h
   protected int selectionEnd; // field_214240_i
   protected int selectionStart; // field_214241_j
   protected long lastClickTime; // field_214242_k (ms)
   protected int cachedPage = -1; // field_214243_l
   protected ChangePageButton buttonNextPage; // field_214244_m
   protected ChangePageButton buttonPreviousPage; // field_214245_n
   protected Button buttonDone; // field_214246_o
   protected Button buttonSign; // field_214247_p
   protected Button buttonFinalize; // field_214248_q
   protected Button buttonCancel; // field_214249_r
   protected final Hand hand;

   public EditBookScreenMod(PlayerEntity player, ItemStack bookIn, Hand handIn) { // PlayerEntity p_i51100_1_, ItemStack p_i51100_2_, Hand p_i51100_3_
      super(NarratorChatListener.EMPTY);
      this.editingPlayer = player;
      this.book = bookIn;
      this.hand = handIn;
      CompoundNBT compoundnbt = bookIn.getTag();
      if (compoundnbt != null) {
         ListNBT listnbt = compoundnbt.getList("pages", 8).copy();

         for(int i = 0; i < listnbt.size(); ++i) {
            this.bookPages.add(listnbt.getString(i));
         }
      }

      if (this.bookPages.isEmpty()) {
         this.bookPages.add("");
      }

   }

   protected int getPageCount() { // func_214199_a
      return this.bookPages.size();
   }

   public void tick() {
      super.tick();
      ++this.updateCount;
   }

   protected void init() {
      this.minecraft.keyboardListener.enableRepeatEvents(true);
      this.buttonSign = this.addButton(new Button(this.width / 2 - 100, 196, 98, 20, I18n.format("book.signButton"), (p_214201_1_) -> {
         this.bookGettingSigned = true;
         this.updateButtons();
      }));
      this.buttonDone = this.addButton(new Button(this.width / 2 + 2, 196, 98, 20, I18n.format("gui.done"), (p_214204_1_) -> {
         this.minecraft.displayGuiScreen((Screen)null);
         this.sendBookToServer(false);
      }));
      this.buttonFinalize = this.addButton(new Button(this.width / 2 - 100, 196, 98, 20, I18n.format("book.finalizeButton"), (p_214195_1_) -> {
         if (this.bookGettingSigned) {
            this.sendBookToServer(true);
            this.minecraft.displayGuiScreen((Screen)null);
         }

      }));
      this.buttonCancel = this.addButton(new Button(this.width / 2 + 2, 196, 98, 20, I18n.format("gui.cancel"), (p_214212_1_) -> {
         if (this.bookGettingSigned) {
            this.bookGettingSigned = false;
         }

         this.updateButtons();
      }));
      int i = (this.width - 192) / 2;
      int j = 2;
      this.buttonNextPage = this.addButton(new ChangePageButton(i + 116, 159, true, (p_214208_1_) -> {
         this.nextPage();
      }, true));
      this.buttonPreviousPage = this.addButton(new ChangePageButton(i + 43, 159, false, (p_214205_1_) -> {
         this.previousPage();
      }, true));
      this.updateButtons();
   }

   /**
    * 
    	Some sort of conversion related to pasting text? 
    	
    	Strips out delete and section characters
    	
    */
   protected String removeUnprintableChars(String text) { 
      StringBuilder stringbuilder = new StringBuilder();

      for(char c0 : text.toCharArray()) {
         if (c0 != 167 && c0 != 127) {  // Character 127 is delete (no symbol) and 167 is the section sign
            stringbuilder.append(c0);
         }
      }

      return stringbuilder.toString();
   }

   protected void previousPage() { // func_214228_b
      if (this.currPage > 0) {
         --this.currPage;
         this.selectionEnd = 0;
         this.selectionStart = this.selectionEnd;
      }

      this.updateButtons();
   }

   protected void nextPage() { // func_214214_c
      if (this.currPage < this.getPageCount() - 1) {
         ++this.currPage;
         this.selectionEnd = 0;
         this.selectionStart = this.selectionEnd;
      } else {
         this.addNewPage();
         if (this.currPage < this.getPageCount() - 1) {
            ++this.currPage;
         }

         this.selectionEnd = 0;
         this.selectionStart = this.selectionEnd;
      }

      this.updateButtons();
   }

   
   public void removed() {
      this.minecraft.keyboardListener.enableRepeatEvents(false);
   }

   
   protected void updateButtons() { // func_214229_d
      this.buttonPreviousPage.visible = !this.bookGettingSigned && this.currPage > 0;
      this.buttonNextPage.visible = !this.bookGettingSigned;
      this.buttonDone.visible = !this.bookGettingSigned;
      this.buttonSign.visible = !this.bookGettingSigned;
      this.buttonCancel.visible = this.bookGettingSigned;
      this.buttonFinalize.visible = this.bookGettingSigned;
      this.buttonFinalize.active = !this.bookTitle.trim().isEmpty();
   }

   
   /*
    * This looks like it strips empty pages at the end of a book. It's only used in sendBookToSever
    */
   protected void trimEmptyPages() { // func_214213_e
      ListIterator<String> listiterator = this.bookPages.listIterator(this.bookPages.size());

      while(listiterator.hasPrevious() && listiterator.previous().isEmpty()) {
         listiterator.remove();
      }

   }

   protected void sendBookToServer(boolean publish) {  // boolean p_214198_1_
      if (this.bookIsModified) {
         this.trimEmptyPages();
         ListNBT listnbt = new ListNBT();
         this.bookPages.stream().map(StringNBT::new).forEach(listnbt::add);
         if (!this.bookPages.isEmpty()) {
            this.book.setTagInfo("pages", listnbt);
         }

         if (publish) {
            this.book.setTagInfo("author", new StringNBT(this.editingPlayer.getGameProfile().getName()));
            this.book.setTagInfo("title", new StringNBT(this.bookTitle.trim()));
         }

         this.minecraft.getConnection().sendPacket(new CEditBookPacket(this.book, publish, this.hand));
      }
   }

   protected void addNewPage() { // func_214215_f
      if (this.getPageCount() < 100) {
         this.bookPages.add("");
         this.bookIsModified = true;
      }
   }

   //                        keyCode (ASCII code)     scanCode         modifiers (shift=1)
   public boolean keyPressed(int p_keyPressed_1_, int p_keyPressed_2_, int p_keyPressed_3_) {
      if (super.keyPressed(p_keyPressed_1_, p_keyPressed_2_, p_keyPressed_3_)) { // returns true if the book is in edit mode (i.e. not the signing screen)
         return true;
      } else {
         return this.bookGettingSigned ? this.keyPressedInTitle(p_keyPressed_1_, p_keyPressed_2_, p_keyPressed_3_) : this.keyPressedInBook(p_keyPressed_1_, p_keyPressed_2_, p_keyPressed_3_);
      }
   }

   public boolean charTyped(char p_charTyped_1_, int p_charTyped_2_) {
      if (super.charTyped(p_charTyped_1_, p_charTyped_2_)) {
         return true;
      } else if (this.bookGettingSigned) {
         if (this.bookTitle.length() < 16 && SharedConstants.isAllowedCharacter(p_charTyped_1_)) {
            this.bookTitle = this.bookTitle + Character.toString(p_charTyped_1_);
            this.updateButtons();
            this.bookIsModified = true;
            return true;
         } else {
            return false;
         }
      } else if (SharedConstants.isAllowedCharacter(p_charTyped_1_)) {
         this.insertTextIntoPage(Character.toString(p_charTyped_1_));
         return true;
      } else {
         return false;
      }
   }

   protected boolean keyPressedInBook(int keyCode, int scanCode, int modifiers) { // func_214230_b int p_214230_1_, int p_214230_2_, int p_214230_3_
      String s = this.getCurrPageText();
      if (Screen.isSelectAll(keyCode)) {
         this.selectionStart = 0;
         this.selectionEnd = s.length();
         return true;
      } else if (Screen.isCopy(keyCode)) {
         this.minecraft.keyboardListener.setClipboardString(this.getSelectedText());
         return true;
      } else if (Screen.isPaste(keyCode)) {
         this.insertTextIntoPage(this.removeUnprintableChars(TextFormatting.getTextWithoutFormattingCodes(this.minecraft.keyboardListener.getClipboardString().replaceAll("\\r", ""))));
         this.selectionStart = this.selectionEnd;
         return true;
      } else if (Screen.isCut(keyCode)) {
         this.minecraft.keyboardListener.setClipboardString(this.getSelectedText());
         this.removeSelectedText();
         return true;
      } else {
         switch(keyCode) {
         case 257: // Return
         case 335: // Enter
            this.insertTextIntoPage("\n");
            return true;
         case 259: // Backspace
            this.backspacePressed(s);
            return true;
         case 261: // delete
            this.deletePressed(s);
            return true;
         case 262: // right
            this.rightPressed(s);
            return true;
         case 263: // left
            this.leftPressed(s);
            return true;
         case 264: // down
            this.downPressed(s);
            return true;
         case 265: // up
            this.upPressed(s);
            return true;
         case 266: // page up
            this.buttonPreviousPage.onPress();
            return true;
         case 267: // page down
            this.buttonNextPage.onPress();
            return true;
         case 268: // home
            this.homePressed(s);
            return true;
         case 269: // end
            this.endPressed(s);
            return true;
         default:
            return false;
         }
      }
   }

   /**
    *  Called when backspace is pressed
    * @param p_214207_1_ is the page text
    */
   protected void backspacePressed(String pageText) { // func_214207_b(String p_214207_1_)
      if (!pageText.isEmpty()) {
         if (this.selectionStart != this.selectionEnd) {
            this.removeSelectedText();
         } else if (this.selectionEnd > 0) {
            String s = (new StringBuilder(pageText)).deleteCharAt(Math.max(0, this.selectionEnd - 1)).toString();
            this.func_214217_j(s);
            this.selectionEnd = Math.max(0, this.selectionEnd - 1);
            this.selectionStart = this.selectionEnd;
         }
      }

   }

   // Delete button pressed
   protected void deletePressed(String pageText) { // func_214221_c(String p_214221_1_) {
      if (!pageText.isEmpty()) {
         if (this.selectionStart != this.selectionEnd) {
            this.removeSelectedText();
         } else if (this.selectionEnd < pageText.length()) {
            String s = (new StringBuilder(pageText)).deleteCharAt(Math.max(0, this.selectionEnd)).toString();
            this.func_214217_j(s);
         }
      }

   }

   protected void leftPressed(String pageText) { // func_214200_d(String p_214200_1_) {
	  // System.out.println("LEFT");
      int i = this.font.getBidiFlag() ? 1 : -1;
      if (Screen.hasControlDown()) {
         this.selectionEnd = this.font.func_216863_a(pageText, i, this.selectionEnd, true);
      } else {
         this.selectionEnd = Math.max(0, this.selectionEnd + i);
      }

      if (!Screen.hasShiftDown()) {
         this.selectionStart = this.selectionEnd;
      }

   }

   protected void rightPressed(String pageText) { //func_214218_e(String p_214218_1_) {
	   //System.out.println("RIGHT");
      int i = this.font.getBidiFlag() ? -1 : 1;
      if (Screen.hasControlDown()) {
         this.selectionEnd = this.font.func_216863_a(pageText, i, this.selectionEnd, true);
      } else {
         this.selectionEnd = Math.min(pageText.length(), this.selectionEnd + i);
      }

      if (!Screen.hasShiftDown()) {
         this.selectionStart = this.selectionEnd;
      }

   }

   protected void upPressed(String pageText) { // func_214197_f(String p_214197_1_) {
	   //System.out.println("UP");
      if (!pageText.isEmpty()) {
         EditBookScreenMod.Point editbookscreen$point = this.func_214194_c(pageText, this.selectionEnd);
         if (editbookscreen$point.y == 0) {
            this.selectionEnd = 0;
            if (!Screen.hasShiftDown()) {
               this.selectionStart = this.selectionEnd;
            }
         } else {
            int i = this.func_214203_a(pageText, new EditBookScreenMod.Point(editbookscreen$point.x + this.func_214206_a(pageText, this.selectionEnd) / 3, editbookscreen$point.y - 9));
            if (i >= 0) {
               this.selectionEnd = i;
               if (!Screen.hasShiftDown()) {
                  this.selectionStart = this.selectionEnd;
               }
            }
         }
      }

   }

   protected void downPressed(String pageText) { // func_214209_g(String p_214209_1_) {
	  // System.out.println("DOWN");
      if (!pageText.isEmpty()) {
         EditBookScreenMod.Point editbookscreen$point = this.func_214194_c(pageText, this.selectionEnd);
         int i = this.font.getWordWrappedHeight(pageText + "" + TextFormatting.BLACK + "_", 114);
         if (editbookscreen$point.y + 9 == i) {
            this.selectionEnd = pageText.length();
            if (!Screen.hasShiftDown()) {
               this.selectionStart = this.selectionEnd;
            }
         } else {
            int j = this.func_214203_a(pageText, new EditBookScreenMod.Point(editbookscreen$point.x + this.func_214206_a(pageText, this.selectionEnd) / 3, editbookscreen$point.y + 9));
            if (j >= 0) {
               this.selectionEnd = j;
               if (!Screen.hasShiftDown()) {
                  this.selectionStart = this.selectionEnd;
               }
            }
         }
      }

   }

   protected void homePressed(String pageText) { // func_214220_h(String p_214220_1_) {
	  // System.out.println("HOME");
      this.selectionEnd = this.func_214203_a(pageText, new EditBookScreenMod.Point(0, this.func_214194_c(pageText, this.selectionEnd).y));
      if (!Screen.hasShiftDown()) {
         this.selectionStart = this.selectionEnd;
      }

   }

   protected void endPressed(String pageText) { // func_214211_i(String p_214211_1_) {
	   //System.out.println("END");
      this.selectionEnd = this.func_214203_a(pageText, new EditBookScreenMod.Point(113, this.func_214194_c(pageText, this.selectionEnd).y));
      if (!Screen.hasShiftDown()) {
         this.selectionStart = this.selectionEnd;
      }

   }

   /**
    * This seems to collapse a text selection down into a single point,  deleting as it goes?
    * Called when you type or press delete/backspace with text selected or 
    */
   protected void removeSelectedText() { // func_214192_g
      if (this.selectionStart != this.selectionEnd) {
         String s = this.getCurrPageText();
         int i = Math.min(this.selectionEnd, this.selectionStart);
         int j = Math.max(this.selectionEnd, this.selectionStart);
         String s1 = s.substring(0, i) + s.substring(j); // There's the deletion
         this.selectionEnd = i;
         this.selectionStart = this.selectionEnd; // Collapse the cursor down to a single point
         this.func_214217_j(s1); // Set the page text to reflect the changes?
      }
   }

   /**
    * Only called by downPressed(S) and upPressed(S), so presumably it's for navigating through text on a page
    * 
    * Returns the width of the character at the given position in a string?
    * 
    * @param p_214206_1_ pageText?
    * @param p_214206_2_ charPos?
    * @return
    */
   protected int func_214206_a(String p_214206_1_, int p_214206_2_) {
      return (int)this.font.getCharWidth(p_214206_1_.charAt(MathHelper.clamp(p_214206_2_, 0, p_214206_1_.length() - 1)));
   }

   /*
    * Handles special characters being typed on the signing screen
    */
   protected boolean keyPressedInTitle(int keyCode, int scanCode, int modifiers) { //func_214196_c  int p_214196_1_, int p_214196_2_, int p_214196_3_
      switch(keyCode) {
      case 257: // Enter
      case 335: // Numpad enter?
         if (!this.bookTitle.isEmpty()) {
            this.sendBookToServer(true);
            this.minecraft.displayGuiScreen((Screen)null);
         }

         return true;
      case 259: // backspace
         if (!this.bookTitle.isEmpty()) {
            this.bookTitle = this.bookTitle.substring(0, this.bookTitle.length() - 1);
            this.updateButtons();
         }

         return true;
      default:
         return false;
      }
   }

   /**
    * Gets the text from the current page
    */
   protected String getCurrPageText() { // func_214193_h
      return this.currPage >= 0 && this.currPage < this.bookPages.size() ? this.bookPages.get(this.currPage) : "";
   }

   
   /**
    * Set current page text
    * @param p_214217_1_ new page text
    */
   protected void func_214217_j(String p_214217_1_) {
      if (this.currPage >= 0 && this.currPage < this.bookPages.size()) {
         this.bookPages.set(this.currPage, p_214217_1_);
         this.bookIsModified = true;
      }

   }

   
   /**
    * Add text to the current page at the cursor?
    */
   protected void insertTextIntoPage(String text) { // func_214202_k String p_214202_1
      if (this.selectionStart != this.selectionEnd) {
         this.removeSelectedText();
      }

      String s = this.getCurrPageText();
      this.selectionEnd = MathHelper.clamp(this.selectionEnd, 0, s.length());
      String s1 = (new StringBuilder(s)).insert(this.selectionEnd, text).toString();
      int i = this.font.getWordWrappedHeight(s1 + "" + TextFormatting.BLACK + "_", 114);
      if (i <= 128 && s1.length() < 1024) {
         this.func_214217_j(s1);
         this.selectionStart = this.selectionEnd = Math.min(this.getCurrPageText().length(), this.selectionEnd + text.length());
      }

   }
   

   public void render(int p_render_1_, int p_render_2_, float p_render_3_) {
      this.renderBackground();
      this.setFocused((IGuiEventListener)null);
      GlStateManager.color4f(1.0F, 1.0F, 1.0F, 1.0F);
      this.minecraft.getTextureManager().bindTexture(ReadBookScreenMod.BOOK_TEXTURES);
      int i = (this.width - 192) / 2;
      int j = 2;
      this.blit(i, 2, 0, 0, 192, 192);
      if (this.bookGettingSigned) {
         String s = this.bookTitle;
         if (this.updateCount / 6 % 2 == 0) {
            s = s + "" + TextFormatting.BLACK + "_";
         } else {
            s = s + "" + TextFormatting.GRAY + "_";
         }

         String s1 = I18n.format("book.editTitle");
         int k = this.getTextWidth(s1);
         this.font.drawString(s1, (float)(i + 36 + (114 - k) / 2), 34.0F, 0);
         int l = this.getTextWidth(s);
         this.font.drawString(s, (float)(i + 36 + (114 - l) / 2), 50.0F, 0);
         String s2 = I18n.format("book.byAuthor", this.editingPlayer.getName().getString());
         int i1 = this.getTextWidth(s2);
         this.font.drawString(TextFormatting.DARK_GRAY + s2, (float)(i + 36 + (114 - i1) / 2), 60.0F, 0);
         String s3 = I18n.format("book.finalizeWarning");
         this.font.drawSplitString(s3, i + 36, 82, 114, 0);
      } else {
         String s4 = I18n.format("book.pageIndicator", this.currPage + 1, this.getPageCount());
         String s5 = this.getCurrPageText();
         int j1 = this.getTextWidth(s4);
         this.font.drawString(s4, (float)(i - j1 + 192 - 44), 18.0F, 0);
         this.font.drawSplitString(s5, i + 36, 32, 114, 0);
         this.highlightSelectedText(s5);
         if (this.updateCount / 6 % 2 == 0) {
            EditBookScreenMod.Point editbookscreen$point = this.func_214194_c(s5, this.selectionEnd);
            if (this.font.getBidiFlag()) {
               this.func_214227_a(editbookscreen$point);
               editbookscreen$point.x = editbookscreen$point.x - 4;
            }

            this.func_214224_c(editbookscreen$point);
            if (this.selectionEnd < s5.length()) {
               AbstractGui.fill(editbookscreen$point.x, editbookscreen$point.y - 1, editbookscreen$point.x + 1, editbookscreen$point.y + 9, -16777216);
            } else {
               this.font.drawString("_", (float)editbookscreen$point.x, (float)editbookscreen$point.y, 0);
            }
         }
      }

      super.render(p_render_1_, p_render_2_, p_render_3_);
   }

   
   protected int getTextWidth(String text) { // func_214225_l(String p_214225_1_) {
      return this.font.getStringWidth(this.font.getBidiFlag() ? this.font.bidiReorder(text) : text);
   }

   protected int func_214216_b(String p_214216_1_, int p_214216_2_) {
      return this.font.sizeStringToWidth(p_214216_1_, p_214216_2_);
   }
   

   /** 
    * Get selected text?
    * only called by keyPressedInBook, (cut/copy to clipboard)
    * @return
    */
   protected String getSelectedText() { // func_214231_i
      String s = this.getCurrPageText();
      int i = Math.min(this.selectionEnd, this.selectionStart);
      int j = Math.max(this.selectionEnd, this.selectionStart);
      return s.substring(i, j);
   }
   

   /**
    * Only called by render()
    * Uses drawSelectionBox to draw blue boxes behind any selected text
    */
   protected void highlightSelectedText(String pageText) { // func_214222_m(String p_214222_1_) {
	   
      if (this.selectionStart != this.selectionEnd) {                    // only runs if there's a selection
    	  
         int i = Math.min(this.selectionEnd, this.selectionStart);       // i is left pos int the pageText
         int j = Math.max(this.selectionEnd, this.selectionStart);       // j is right pos in the pageText
         String s = pageText.substring(i, j);                            // s is the selected text
         int k = this.font.func_216863_a(pageText, 1, j, true);          // k seems to be the next whitespace after the selection, e.g. where the line could be wrapped
         String s1 = pageText.substring(i, k);	                         // s1 is the string up to k
         
         // These seem to start with the xy pos of the selection start cursor (i.e. a vertical line to the immedate left of the first line of the selection)
         EditBookScreenMod.Point editbookscreen$point = this.func_214194_c(pageText, i);
         EditBookScreenMod.Point editbookscreen$point1 = new EditBookScreenMod.Point(editbookscreen$point.x, editbookscreen$point.y + 9);

         // This draws the highlight on each successive line
         while(!s.isEmpty()) {
            int l = this.func_214216_b(s1, 114 - editbookscreen$point.x); // I think this might get the position of the end of the line?
            if (s.length() <= l) {
               editbookscreen$point1.x = editbookscreen$point.x + this.getTextWidth(s);
               this.drawSelectionBox(editbookscreen$point, editbookscreen$point1);
               break;
            }

            l = Math.min(l, s.length() - 1);
            String s2 = s.substring(0, l);
            char c0 = s.charAt(l);
            boolean flag = c0 == ' ' || c0 == '\n';
            s = TextFormatting.getFormatString(s2) + s.substring(l + (flag ? 1 : 0));
            s1 = TextFormatting.getFormatString(s2) + s1.substring(l + (flag ? 1 : 0));
            editbookscreen$point1.x = editbookscreen$point.x + this.getTextWidth(s2 + " ");
            this.drawSelectionBox(editbookscreen$point, editbookscreen$point1);
            editbookscreen$point.x = 0;
            editbookscreen$point.y = editbookscreen$point.y + 9;
            editbookscreen$point1.y = editbookscreen$point1.y + 9;
         }

      }
   }

   /**
    * Draw the blue selection box 
    * Params are probably box corners
    * @param p_214223_1_ top left?
    * @param p_214223_2_ bottom right?
    */
   protected void drawSelectionBox(EditBookScreenMod.Point topLeft, EditBookScreenMod.Point bottomRight) { // func_214223_a(EditBookScreenMod.Point p_214223_1_, EditBookScreenMod.Point p_214223_2_) {
      EditBookScreenMod.Point editbookscreen$point = new EditBookScreenMod.Point(topLeft.x, topLeft.y);
      EditBookScreenMod.Point editbookscreen$point1 = new EditBookScreenMod.Point(bottomRight.x, bottomRight.y);
      if (this.font.getBidiFlag()) {
         this.func_214227_a(editbookscreen$point);
         this.func_214227_a(editbookscreen$point1);
         int i = editbookscreen$point1.x;
         editbookscreen$point1.x = editbookscreen$point.x;
         editbookscreen$point.x = i;
      }

      this.func_214224_c(editbookscreen$point);
      this.func_214224_c(editbookscreen$point1);
      Tessellator tessellator = Tessellator.getInstance();
      BufferBuilder bufferbuilder = tessellator.getBuffer();
      GlStateManager.color4f(0.0F, 0.0F, 255.0F, 255.0F);
      GlStateManager.disableTexture();
      GlStateManager.enableColorLogicOp();
      GlStateManager.logicOp(GlStateManager.LogicOp.OR_REVERSE);
      bufferbuilder.begin(7, DefaultVertexFormats.POSITION);
      bufferbuilder.pos((double)editbookscreen$point.x, (double)editbookscreen$point1.y, 0.0D).endVertex();
      bufferbuilder.pos((double)editbookscreen$point1.x, (double)editbookscreen$point1.y, 0.0D).endVertex();
      bufferbuilder.pos((double)editbookscreen$point1.x, (double)editbookscreen$point.y, 0.0D).endVertex();
      bufferbuilder.pos((double)editbookscreen$point.x, (double)editbookscreen$point.y, 0.0D).endVertex();
      tessellator.draw();
      GlStateManager.disableColorLogicOp();
      GlStateManager.enableTexture();
   }

   /**
    * Called when up, down, home, or end are pressed
    * Also called in render() and func_214222_m()
    * 
    * Returns the XY position in the text (first param) for the position indicated by the second parameter (between chars I think)
    * 
    * @param p_214194_1_ pageText?
    * @param p_214194_2_
    * @return
    */
   protected EditBookScreenMod.Point func_214194_c(String pageText, int p_214194_2_) { // func_214194_c(String p_214194_1_, int p_214194_2_) {
      EditBookScreenMod.Point editbookscreen$point = new EditBookScreenMod.Point();
      int i = 0;
      int j = 0;

      for(String s = pageText; !s.isEmpty(); j = i) {
         int k = this.func_214216_b(s, 114);
         if (s.length() <= k) {
            String s3 = s.substring(0, Math.min(Math.max(p_214194_2_ - j, 0), s.length()));
            editbookscreen$point.x = editbookscreen$point.x + this.getTextWidth(s3);
            break;
         }

         String s1 = s.substring(0, k);
         char c0 = s.charAt(k);
         boolean flag = c0 == ' ' || c0 == '\n';
         s = TextFormatting.getFormatString(s1) + s.substring(k + (flag ? 1 : 0));
         i += s1.length() + (flag ? 1 : 0);
         if (i - 1 >= p_214194_2_) {
            String s2 = s1.substring(0, Math.min(Math.max(p_214194_2_ - j, 0), s1.length()));
            editbookscreen$point.x = editbookscreen$point.x + this.getTextWidth(s2);
            break;
         }

         editbookscreen$point.y = editbookscreen$point.y + 9;
      }

      return editbookscreen$point;
   }

   /**
    * Called by drawSelectionBox(), mouseClicked(), mouseDragged(), and render()
    * Something to do with right to left text? 
    * @param p_214227_1_
    */
   protected void func_214227_a(EditBookScreenMod.Point p_214227_1_) {
      if (this.font.getBidiFlag()) {
         p_214227_1_.x = 114 - p_214227_1_.x;
      }

   }

   /**
    * Called when selecting text?
    * @param p_214210_1_
    */
   protected void func_214210_b(EditBookScreenMod.Point p_214210_1_) {
      p_214210_1_.x = p_214210_1_.x - (this.width - 192) / 2 - 36;
      p_214210_1_.y = p_214210_1_.y - 32;
   }

   /** 
    * Called when text is deselected or clicked?
    * Called when the book is opened too. Maybe sets the vertical cursor?
    * @param p_214224_1_
    */
   protected void func_214224_c(EditBookScreenMod.Point p_214224_1_) {
      p_214224_1_.x = p_214224_1_.x + (this.width - 192) / 2 + 36;
      p_214224_1_.y = p_214224_1_.y + 32;
   }

   
   /**
    * Only called by func_214203_a(S,P)
    * @param p_214226_1_
    * @param p_214226_2_
    * @return
    */
   protected int func_214226_d(String p_214226_1_, int p_214226_2_) {
      if (p_214226_2_ < 0) {
         return 0;
      } else {
         float f1 = 0.0F;
         boolean flag = false;
         String s = p_214226_1_ + " ";

         for(int i = 0; i < s.length(); ++i) {
            char c0 = s.charAt(i);
            float f2 = this.font.getCharWidth(c0);
            if (c0 == 167 && i < s.length() - 1) {
               ++i;
               c0 = s.charAt(i);
               if (c0 != 'l' && c0 != 'L') {
                  if (c0 == 'r' || c0 == 'R') {
                     flag = false;
                  }
               } else {
                  flag = true;
               }

               f2 = 0.0F;
            }

            float f = f1;
            f1 += f2;
            if (flag && f2 > 0.0F) {
               ++f1;
            }

            if ((float)p_214226_2_ >= f && (float)p_214226_2_ < f1) {
               return i;
            }
         }

         if ((float)p_214226_2_ >= f1) {
            return s.length() - 1;
         } else {
            return -1;
         }
      }
   }

   /**
    * Something about finding a point within a string?
    * @param p_214203_1_
    * @param p_214203_2_
    * @return
    */
   protected int func_214203_a(String p_214203_1_, EditBookScreenMod.Point p_214203_2_) {
      int i = 16 * 9;
      if (p_214203_2_.y > i) {
         return -1;
      } else {
         int j = Integer.MIN_VALUE;
         int k = 9;
         int l = 0;

         for(String s = p_214203_1_; !s.isEmpty() && j < i; k += 9) {
            int i1 = this.func_214216_b(s, 114);
            if (i1 < s.length()) {
               String s1 = s.substring(0, i1);
               if (p_214203_2_.y >= j && p_214203_2_.y < k) {
                  int k1 = this.func_214226_d(s1, p_214203_2_.x);
                  return k1 < 0 ? -1 : l + k1;
               }

               char c0 = s.charAt(i1);
               boolean flag = c0 == ' ' || c0 == '\n';
               s = TextFormatting.getFormatString(s1) + s.substring(i1 + (flag ? 1 : 0));
               l += s1.length() + (flag ? 1 : 0);
            } else if (p_214203_2_.y >= j && p_214203_2_.y < k) {
               int j1 = this.func_214226_d(s, p_214203_2_.x);
               return j1 < 0 ? -1 : l + j1;
            }

            j = k;
         }

         return p_214203_1_.length();
      }
   }

   public boolean mouseClicked(double p_mouseClicked_1_, double p_mouseClicked_3_, int p_mouseClicked_5_) {
      if (p_mouseClicked_5_ == 0) {
         long i = Util.milliTime();
         String s = this.getCurrPageText();
         if (!s.isEmpty()) {
            EditBookScreenMod.Point editbookscreen$point = new EditBookScreenMod.Point((int)p_mouseClicked_1_, (int)p_mouseClicked_3_);
            this.func_214210_b(editbookscreen$point);
            this.func_214227_a(editbookscreen$point);
            int j = this.func_214203_a(s, editbookscreen$point);
            if (j >= 0) {
               if (j == this.cachedPage && i - this.lastClickTime < 250L) { // True if you double click
                  if (this.selectionStart == this.selectionEnd) {
                     this.selectionStart = this.font.func_216863_a(s, -1, j, false);
                     this.selectionEnd = this.font.func_216863_a(s, 1, j, false);
                  } else {
                     this.selectionStart = 0;
                     this.selectionEnd = this.getCurrPageText().length();
                  }
               } else {
                  this.selectionEnd = j;
                  if (!Screen.hasShiftDown()) {
                     this.selectionStart = this.selectionEnd;
                  }
               }
            }

            this.cachedPage = j;
         }

         this.lastClickTime = i;
      }

      return super.mouseClicked(p_mouseClicked_1_, p_mouseClicked_3_, p_mouseClicked_5_);
   }

   /**
    * Used for selecting text I think?
    * Continuously called while the mouse button is down
    *
    *                                    currX?                     currY?               activeButton               distanceX?                distanceY?
    */
   public boolean mouseDragged(double p_mouseDragged_1_, double p_mouseDragged_3_, int p_mouseDragged_5_, double p_mouseDragged_6_, double p_mouseDragged_8_) {
      if (p_mouseDragged_5_ == 0 && this.currPage >= 0 && this.currPage < this.bookPages.size()) {
    	 //System.out.println("mouseDragged " + p_mouseDragged_6_);
         String s = this.bookPages.get(this.currPage);
         EditBookScreenMod.Point editbookscreen$point = new EditBookScreenMod.Point((int)p_mouseDragged_1_, (int)p_mouseDragged_3_);
         this.func_214210_b(editbookscreen$point);
         this.func_214227_a(editbookscreen$point);
         int i = this.func_214203_a(s, editbookscreen$point);
         if (i >= 0) {
            this.selectionEnd = i;
         }
      }

      return super.mouseDragged(p_mouseDragged_1_, p_mouseDragged_3_, p_mouseDragged_5_, p_mouseDragged_6_, p_mouseDragged_8_);
   }

   @OnlyIn(Dist.CLIENT)
   class Point {
      protected int x; // field_216928_b
      protected int y; // field_216929_c

      Point() {
      }

      Point(int xIn, int yIn) { // int p_i50636_2_, int p_i50636_3_
         this.x = xIn;
         this.y = yIn;
      }
   }
}